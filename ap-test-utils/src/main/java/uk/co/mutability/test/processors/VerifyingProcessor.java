/*
 * This file is part of the ap-test-utils package.
 * 
 * Copyright (C) 2012 Oliver Jowett <oliver@mutability.co.uk>
 *
 * ap-test-utils is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *  
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with ap-test-utils. If not, see <http://www.gnu.org/licenses/>.
 *
 */

package uk.co.mutability.test.processors;

import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import javax.annotation.processing.Completion;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.AnnotationValue;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.ElementScanner6;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic;
import javax.tools.Diagnostic.Kind;

/**
 * An annotation processor for testing annotation processors. (Say <b>that</b> ten times fast!)
 * <p>
 * This processor (the "verifying processor") wraps another processor (the "delegate processor") which is provided either explicitly when directly constructed,
 * or via an annotation processor argument when called by the compiler.
 * <p>
 * The verifying processor expects to operate on a test class that has {@link VerifyDiagnostics} and {@link ExpectDiagnostic}/{@link ExpectDiagnostics}
 * annotations that indicate diagnostics that should be generated. It allows the delegate processor to process the test class, and intercepts diagnostics
 * generated by the delegate processor. If the diagnostics match what is expected, all is well and the diagnostic is not propagated to the compiler itself. If
 * they do not match, the diagnostic is propagated to the compiler as an error.
 * <p>
 * The overall effect is that if the correct diagnostics are generated, there should be no compiler diagnostics generated. Otherwise, if some compiler
 * diagnostics are seen, the test has failed.
 * <p>
 * The verifying processor provides wrapper implementations of some of the processor SPI. Notably, it wraps {@link Messager} so that can intercept and check
 * diagnostics generated by the delegate processor; {@link ProcessingEnvironment} so that it can provide the wrapped Messager to the delegate processor; and
 * {@link RoundEnvironment} so that the verifying processor can stop processing "early" if the delegate processor generated an error diagnostic that was
 * expected and therefore not passed to the real compiler.
 */
public class VerifyingProcessor implements Processor {
    /** The well-known annotation processor option name we use to find the delegate processor. */
    public static final String DELEGATE_OPTION_NAME = "mutabilty.test.delegateClassName";

    /** The delegate processor we are testing, or null if it is not yet determined */
    private Processor delegate;
    /** The real ProcessingEnvironment that the compiler gave us */
    private ProcessingEnvironment realEnv;
    /** The wrapped ProcessingEnvironment that we will give to the delegate processor */
    private WrapperEnvironment wrapperEnv;
    /** The wrapped Messager that we will give to the delegate processor */
    private WrapperMessager wrapperMessager;
    /** If true, the delegate raised an error diagnostic at some point, so we should stop processing in the next round. */
    private boolean delegateGeneratedError;
    /** If true, we have run the final processing round on the delegate */
    private boolean delegateProcessingOver;

    /**
     * A data-holding class that represents one expected diagnostic.
     */
    private static class ElementAndDiagnostic {
        ElementAndDiagnostic(Element annotatedElement, boolean matchElement, String regex, Diagnostic.Kind kind) throws PatternSyntaxException {
            this.annotatedElement = annotatedElement;
            this.matchElement = matchElement;
            this.pattern = Pattern.compile(regex);
            this.kind = kind;
        }

        final Element annotatedElement;
        final boolean matchElement;
        final Pattern pattern;
        final Diagnostic.Kind kind;

        boolean matched = false;
    }

    /** All the diagnostics we expect to see in this particular round */
    private List<ElementAndDiagnostic> expectedDiagnostics = new ArrayList<ElementAndDiagnostic>();

    /**
     * Add a new diagnostic to the set of expected diagnostics for this round. May generate a compiler diagnostic if the contained regular expression has syntax
     * errors.
     * 
     * @param diag the diagnostic annotation to add
     * @param annotatedElement the element that the annotation was attached to
     * @param matchElement true if this diagnostic should be matched against the annotated element, false if it is a detached match
     */
    private void addExpectedDiagnostic(ExpectDiagnostic diag, Element annotatedElement, boolean matchElement) {
        try {
            expectedDiagnostics.add(new ElementAndDiagnostic(annotatedElement, matchElement, diag.value(), diag.kind()));
        } catch (PatternSyntaxException e) {
            realEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                               "Syntax error in diagnostic regular expression '" + diag.value() + "': " + e.getMessage(), annotatedElement);
        }
    }

    /**
     * Construct a verifying processor that will find the delegate processor at init() time based on annotation processor options.
     */
    public VerifyingProcessor() {
        this.delegate = null;
    }

    /**
     * Construct a verifying processor that uses the given delegate; used when directly constructing a processor chain to give to the javax.tool interface.
     * 
     * @param delegate the delegate processor instance
     */
    public VerifyingProcessor(Processor delegate) {
        this.delegate = delegate;
    }

    @Override
    public void init(ProcessingEnvironment processingEnv) {
        this.realEnv = processingEnv;
        this.wrapperEnv = new WrapperEnvironment();
        this.wrapperMessager = new WrapperMessager();
        this.delegateGeneratedError = false;
        this.delegateProcessingOver = false;

        if (delegate == null) {
            // Try to find the delegate via annotation processor options
            String className = realEnv.getOptions().get(DELEGATE_OPTION_NAME);
            if (className == null) {
                realEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                                   "No delegate processor available, please specify the " + DELEGATE_OPTION_NAME + " option");
                return;
            }

            // Try to build an instance of it.
            try {
                delegate = Class.forName(className).asSubclass(Processor.class).newInstance();
            } catch (Exception e) {
                realEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                                   "Unable to construct the delegate processor " + className + " due to an exception: " + e.getMessage());
                return;
            }
        }

        delegate.init(wrapperEnv);
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        // Add our annotations to the set returned by the underlying processor.
        HashSet<String> delegateSet = new HashSet<String>();
        if (delegate != null)
            delegateSet.addAll(delegate.getSupportedAnnotationTypes());
        delegateSet.add("uk.co.mutability.test.processors.*");
        return delegateSet;
    }

    @Override
    public Iterable<? extends Completion> getCompletions(Element element, AnnotationMirror annotation, ExecutableElement member, String userText) {
        // We don't implement this.
        if (delegate == null)
            return Collections.emptyList();

        return delegate.getCompletions(element, annotation, member, userText);
    }

    @Override
    public Set<String> getSupportedOptions() {
        // Add our option to the set returned by the underlying processor
        HashSet<String> delegateSet = new HashSet<String>();
        if (delegate != null)
            delegateSet.addAll(delegate.getSupportedOptions());
        delegateSet.add(DELEGATE_OPTION_NAME);
        return delegateSet;
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        if (delegate == null)
            return SourceVersion.RELEASE_6;
        return delegate.getSupportedSourceVersion();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // If we ran a "last round" for the delegate, don't do any more.
        if (delegateProcessingOver)
            return false;

        // Do our own processing first to discover the diagnostics we expect.
        expectedDiagnostics.clear();

        for (Element rootElement : roundEnv.getRootElements()) {
            if (rootElement.getAnnotation(VerifyDiagnostics.class) != null) {
                ElementScanner6<Void,Void> scanner = new ElementScanner6<Void,Void>() {
                    @Override
                    public Void scan(Element annotatedElement, Void p) {
                        VerifyDiagnostics verify = annotatedElement.getAnnotation(VerifyDiagnostics.class);
                        if (verify != null) {
                            for (ExpectDiagnostic diag : verify.generalDiagnostics())
                                addExpectedDiagnostic(diag, annotatedElement, false);
                        }

                        ExpectDiagnostic singleDiag = annotatedElement.getAnnotation(ExpectDiagnostic.class);
                        if (singleDiag != null) {
                            addExpectedDiagnostic(singleDiag, annotatedElement, true);
                        }

                        ExpectDiagnostics diags = annotatedElement.getAnnotation(ExpectDiagnostics.class);
                        if (diags != null) {
                            for (ExpectDiagnostic diag : diags.value())
                                addExpectedDiagnostic(diag, annotatedElement, true);
                        }

                        return super.scan(annotatedElement, p);
                    }
                };

                scanner.scan(rootElement, null);
            }
        }

        // Build a new wrapper RoundEnvironment that reflects the errors generated
        // by the delegate, not the errors we actually reported
        WrapperRoundEnvironment wrapperRoundEnv = new WrapperRoundEnvironment(roundEnv, delegateGeneratedError);

        // Delegate to the delegate processor to do the real processing
        boolean takeAnnotations = delegate.process(annotations, wrapperRoundEnv);

        // Check for unconsumed diagnostics
        for (ElementAndDiagnostic diag : expectedDiagnostics) {
            if (diag.matched)
                continue;

            realEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                               "Expected " + diag.kind + " diagnostic matching regex '" + diag.pattern.pattern() +
                                               "' but no matching diagnostic was generated.",
                                               diag.annotatedElement);
        }

        // If we just ran an artificial "last round", remember that.
        delegateProcessingOver = wrapperRoundEnv.processingOver();
        return takeAnnotations;
    }

    private class WrapperRoundEnvironment implements RoundEnvironment {
        private final RoundEnvironment delegateEnv;
        private final boolean lastRoundHadErrors;

        private WrapperRoundEnvironment(RoundEnvironment delegateEnv, boolean lastRoundHadErrors) {
            this.delegateEnv = delegateEnv;
            this.lastRoundHadErrors = lastRoundHadErrors;
        }

        @Override
        public boolean errorRaised() {
            return lastRoundHadErrors || delegateEnv.errorRaised();
        }

        @Override
        public Set<? extends Element> getElementsAnnotatedWith(Class<? extends Annotation> a) {
            return delegateEnv.getElementsAnnotatedWith(a);
        }

        @Override
        public Set<? extends Element> getElementsAnnotatedWith(TypeElement a) {
            return delegateEnv.getElementsAnnotatedWith(a);
        }

        @Override
        public Set<? extends Element> getRootElements() {
            return delegateEnv.getRootElements();
        }

        @Override
        public boolean processingOver() {
            return lastRoundHadErrors || delegateEnv.processingOver();
        }
    }

    private class WrapperEnvironment implements ProcessingEnvironment {
        @Override
        public Map<String,String> getOptions() {
            return realEnv.getOptions();
        }

        @Override
        public Messager getMessager() {
            return wrapperMessager;
        }

        @Override
        public Filer getFiler() {
            return realEnv.getFiler();
        }

        @Override
        public Elements getElementUtils() {
            return realEnv.getElementUtils();
        }

        @Override
        public Types getTypeUtils() {
            return realEnv.getTypeUtils();
        }

        @Override
        public SourceVersion getSourceVersion() {
            return realEnv.getSourceVersion();
        }

        @Override
        public Locale getLocale() {
            return realEnv.getLocale();
        }
    }

    private class WrapperMessager implements Messager {
        @Override
        public void printMessage(Kind kind, CharSequence msg) {
            matchDiagnostic(kind, msg, null);
        }

        @Override
        public void printMessage(Kind kind, CharSequence msg, Element e) {
            matchDiagnostic(kind, msg, e);
        }

        @Override
        public void printMessage(Kind kind, CharSequence msg, Element e, AnnotationMirror a) {
            matchDiagnostic(kind, msg, e);
        }

        @Override
        public void printMessage(Kind kind, CharSequence msg, Element e, AnnotationMirror a, AnnotationValue v) {
            matchDiagnostic(kind, msg, e);
        }

        private void matchDiagnostic(Kind kind, CharSequence msg, Element e) {
            if (kind == Diagnostic.Kind.ERROR)
                delegateGeneratedError = true;

            boolean matched = false;
            for (Iterator<ElementAndDiagnostic> i = expectedDiagnostics.iterator(); i.hasNext();) {
                ElementAndDiagnostic diag = i.next();
                if (diag.kind == kind && (diag.matchElement && e != null && e.equals(diag.annotatedElement) || !diag.matchElement && e == null) &&
                    diag.pattern.matcher(msg).find()) {
                    diag.matched = matched = true;
                }
            }

            if (!matched) {
                realEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                                   "Unexpected " + kind + " diagnostic generated by processor: " + msg, e);
            }
        }
    }
}
